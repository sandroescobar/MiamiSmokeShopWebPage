<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Secure checkout</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --ink:#0f172a;
      --ink-dim:#475569;
      --ink-soft:#64748b;
      --line:#e2e8f0;
      --brand:#111827;
      --brand-ink:#ffffff;
      --pill:#f1f5f9;
      --focus:#4f46e5;
      --ok:#16a34a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font: 14px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    /* Page shell */
    .page{
      max-width: 1200px; margin: 24px auto; padding: 0 16px 48px;
    }
    .mast{display:flex; align-items:center; gap:12px; margin: 6px 0 18px;}
    .mast h1{font-size:28px; margin:0; font-weight:700}
    .eyebrow{font-size:13px; color:var(--ink-soft); margin-bottom: 18px;}

    /* Layout */
    .grid{
      display:grid; gap: 24px;
      grid-template-columns: 1fr 360px;
    }
    @media (max-width: 960px){
      .grid{grid-template-columns: 1fr}
    }

    /* Cards */
    .card{
      background:var(--card); border:1px solid var(--line);
      border-radius:12px; box-shadow: 0 4px 14px rgba(15,23,42,.06);
    }
    .card .card-body{ padding: 18px; }
    .section{margin-bottom: 18px;}
    .section h3{
      font-size: 14px; letter-spacing:.02em; text-transform: uppercase;
      color:var(--ink-dim); margin: 0 0 10px; font-weight:700;
    }

    /* Option pills (pickup / delivery) */
    .option-row{
      display:grid; gap:12px; grid-template-columns: 1.2fr 1.2fr;
    }
    @media (max-width: 600px){ .option-row{grid-template-columns:1fr} }
    .option{
      position:relative; border:1px solid var(--line); border-radius:12px; background:#fff;
      padding:14px; display:flex; gap:12px; align-items:center; cursor:pointer;
    }
    .option input{ position:absolute; inset:0; opacity:0; }
    .option .icon{
      width:28px; height:28px; border-radius:8px; display:grid; place-items:center; background:var(--pill);
      font-size:16px;
    }
    .option .title{ font-weight:600; }
    .option .sub{ color:var(--ink-soft); font-size:13px; }
    .option:has(input:checked){
      border-color: var(--focus); box-shadow:0 0 0 4px rgba(79,70,229,.12);
    }

    /* Form fields */
    .row{ display:grid; gap:12px; grid-template-columns: 1.2fr 1.2fr; }
    .row-1{ grid-template-columns: 1fr; }
    @media (max-width: 680px){ .row{grid-template-columns:1fr} }

    label{ display:block; font-weight:600; font-size:13px; margin: 8px 0 6px; color:var(--ink) }
    input, select, textarea{
      width:100%; border:1px solid var(--line); background:#fff; color:var(--ink);
      border-radius:10px; padding:12px 14px; font: inherit; outline: none;
    }
    input:focus, select:focus, textarea:focus{ border-color:var(--focus); box-shadow:0 0 0 3px rgba(79,70,229,.15); }

    /* Order summary */
    .summary .totals{ border-top:1px solid var(--line); margin-top: 14px; padding-top: 14px; }
    .line{ display:flex; justify-content:space-between; margin: 8px 0; }
    .grand{ font-weight:800; font-size:18px; }

    /* Store selection */
    .store-selector { margin-top: 12px; }
    .store-option {
      position: relative; border: 1px solid var(--line); border-radius: 10px;
      background: #fff; padding: 12px 14px; margin-bottom: 10px; cursor: pointer;
      transition: all 0.2s;
    }
    .store-option:hover { border-color: var(--focus); }
    .store-option input { position: absolute; inset: 0; opacity: 0; }
    .store-option .store-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .store-option .store-name { font-weight: 600; }
    .store-option .availability { font-size: 11px; padding: 2px 8px; border-radius: 6px; background: var(--pill); }
    .store-option .availability.available { background: #dcfce7; color: #166534; }
    .store-option .availability.unavailable { background: #fee2e2; color: #991b1b; }
    .store-option .store-address { font-size: 12px; color: var(--ink-soft); margin-bottom: 4px; }
    .store-option .store-distance { font-size: 12px; color: var(--ink-soft); }
    .store-option:has(input:checked) { border-color: var(--focus); box-shadow: 0 0 0 3px rgba(79,70,229,.15); }

    /* Disabled store (not fully stocked for this cart) */
    .store-option.disabled { opacity: .55; cursor: not-allowed; }
    .store-option.disabled:hover { border-color: var(--line); }

    .availability-notice { font-size: 13px; color: #475569; margin-top: 10px; padding: 10px;
      background: #f1f5f9; border-radius: 8px; border-left: 3px solid var(--focus); }
    .best-badge { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: #4f46e5; color: #fff; font-weight: 700; text-transform: uppercase; margin-left: 8px; vertical-align: middle; }
    .loading { color: var(--ink-soft); font-size: 13px; margin-top: 8px; }

    /* Buttons */
    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:12px 16px; border-radius:10px; border:1px solid transparent;
      cursor:pointer; font-weight:700; text-decoration:none;
    }
    .btn-primary{ background:var(--brand); color:var(--brand-ink); }
    .btn-secondary{ background:#fff; border-color:var(--line); color:var(--ink) }
    .btn:disabled{ opacity:.6; pointer-events:none }

    .actions{ display:flex; gap:12px; margin-top:14px; flex-wrap:wrap; justify-content: center; align-items: center}
    .payment-header{display:flex;align-items:center;justify-content:flex-start;gap:8px;margin:0;flex-wrap:wrap}
    .payment-header h3{margin:0}
    .card-brand-logos{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .card-brand-logos svg{height:20px;width:auto;display:block}
    .payment-body{margin-top:4px}
    .payment-card{border-style:dashed;margin-top:4px}
    .policy-links{margin-top:12px;display:flex;gap:12px;flex-wrap:wrap;font-size:12px}
    .policy-links a{color:#0a7fd6;text-decoration:none}
    .policy-links a:hover{text-decoration:underline}
    .policy-modal{position:fixed;inset:0;background:rgba(15,23,42,.7);display:none;align-items:center;justify-content:center;padding:24px;z-index:2000}
    .policy-modal.show{display:flex}
    .policy-modal__dialog{background:#fff;border-radius:16px;width:100%;max-width:760px;max-height:90vh;overflow:auto;box-shadow:0 20px 60px rgba(15,23,42,.35);position:relative;padding:28px}
    .policy-modal__close{position:absolute;top:12px;right:12px;border:none;background:rgba(15,23,42,.08);color:#0f172a;width:32px;height:32px;border-radius:50%;font-size:18px;cursor:pointer}
    .policy-modal__content h4{margin:0;font-size:20px}
    .policy-modal__content p{color:#475569}
    .policy-modal__body{margin-top:16px;display:flex;flex-direction:column;gap:16px;font-size:14px;color:#0f172a}
    .policy-modal__body h2,.policy-modal__body h3{margin:12px 0 4px;font-size:16px}
    .policy-modal__body ul{padding-left:18px;margin:0}
    .policy-modal__loading{color:#475569;font-size:14px;margin:0}
    .policy-modal__error{color:#b91c1c;font-size:14px;margin:0}

    /* ---------------- ZenPayments Hosted Fields ---------------- */
    .zp-fields { display: grid; gap: 12px; }
    .zp-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .zp-label { font-size: 0.85rem; font-weight: 600; color: #334155; margin-bottom: 6px; display:block; }
    .zp-input {
      min-height: 44px;
      border: 1px solid #cbd5e1;
      border-radius: 10px;
      background: #fff;
      padding: 10px 12px;
      display: flex;
      align-items: center;
    }
    input.zp-input{display:block;}
    .zp-hint { font-size: 0.85rem; color: #64748b; margin-top: 6px; }
    .zp-error { color: #b91c1c; font-size: 0.9rem; margin-top: 8px; }
    .zp-success { color: #15803d; font-size: 0.9rem; margin-top: 8px; }

    /* Address clear button */
    .input-wrapper { position: relative; width: 100%; }
    .input-clear-btn {
      position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
      background: #e2e8f0; border: none; width: 24px; height: 24px; border-radius: 50%;
      display: none; align-items: center; justify-content: center;
      cursor: pointer; color: #475569; font-size: 14px; font-weight: 700;
      transition: all 0.2s; z-index: 10;
    }
    .input-clear-btn:hover { background: #cbd5e1; color: #0f172a; }
    .input-wrapper:has(input:not(:placeholder-shown)) .input-clear-btn { display: flex; }
    input[name="street"] { padding-right: 44px; }
  </style>
</head>
<body>

  <div class="page">
    <div class="mast">
      <h1>Secure checkout</h1>
    </div>
    <div class="eyebrow">Pick up in-store or get fast Uber Delivery</div>

    <div class="grid">
      <!-- LEFT: form -->
      <div>
        <div class="card">
          <div class="card-body">
            <div class="section">
              <h3>Delivery options</h3>
              <div class="option-row">
                <label class="option">
                  <input type="radio" name="delivery_method" value="pickup" checked>
                  <div class="icon">üè™</div>
                  <div>
                    <div class="title">Store pickup</div>
                    <div class="sub">Free pickup at our Miami location</div>
                  </div>
                </label>

                <label class="option">
                  <input type="radio" name="delivery_method" value="delivery">
                  <div class="icon">üõµ</div>
                  <div>
                    <div class="title">Uber Delivery</div>
                    <div class="sub">On-demand courier to your door</div>
                  </div>
                </label>
              </div>

              <!-- Store Selection (Pickup) -->
              <div id="pickup-stores-section" style="margin-top: 16px;">
                <h3 style="margin-top: 12px; margin-bottom: 8px;">Select pickup location</h3>
                <div id="pickup-stores" class="store-selector"></div>
                <div id="pickup-availability-notice" class="availability-notice" style="display:none;"></div>
              </div>
python3
              <!-- Store Detection (Delivery) -->
              <div id="delivery-stores-section" style="margin-top: 16px; display:none;">
                <h3 id="delivery-header" style="margin-top: 12px; margin-bottom: 8px;">Delivery to</h3>
                <p id="delivery-store-helper" class="loading" style="display:block; margin-top:4px;">Enter your address to compare store inventory and delivery fees.</p>
                <div id="delivery-availability-notice" class="availability-notice" style="display:none;"></div>
                <div id="closest-store-info" style="margin-top: 10px; padding: 10px; background: #f0f9ff; border-radius: 8px; border-left: 3px solid #0284c7; display:none;">
                  <div style="font-weight: 600; margin-bottom: 4px;">üìç <span id="closest-store-name"></span></div>
                  <div style="font-size: 12px; color: #475569; margin-bottom: 2px;"><span id="closest-store-address"></span></div>
                  <div style="font-size: 12px; color: #0284c7; font-weight: 500;">~<span id="closest-store-distance"></span> miles away ‚Ä¢ Delivery fee $<span id="closest-store-fee"></span></div>
                </div>
                <div id="delivery-stores" class="store-selector" style="display:none; margin-top: 12px;"></div>
              </div>
            </div>

            <div class="section">
              <h3>Contact</h3>
              <div class="row-1">
                <label>Email address
                  <input type="email" name="email" placeholder="you@email.com" required>
                </label>
              </div>
              <div class="row">
                <label>First name
                  <input type="text" name="first_name" placeholder="First name" required>
                </label>
                <label>Last name
                  <input type="text" name="last_name" placeholder="Last name" required>
                </label>
              </div>
              <div class="row-1">
                <label>Phone number
                  <input type="tel" name="phone" placeholder="(305) 555-0123" required>
                </label>
              </div>

            <label>Date of Birth</label>
<div style="display:flex; gap:10px; margin-bottom:15px;">
  <input type="number" id="dob_month" name="dob_month" placeholder="MM" min="1" max="12" required>
  <input type="number" id="dob_day" name="dob_day" placeholder="DD" min="1" max="31" required>
  <input type="number" id="dob_year" name="dob_year" placeholder="YYYY" min="1900" max="2026" required>
</div>


            </div>

            <div class="section" id="address-section">
              <h3>Delivery address</h3>
              <div class="row-1">
                <label>Street address
                  <div class="input-wrapper">
                    <input type="text" name="street" placeholder="123 Main Street" required autocomplete="off">
                    <button type="button" class="input-clear-btn" id="clear-street-btn" aria-label="Clear address">&times;</button>
                  </div>
                </label>
              </div>
              <div class="row-1">
                <label>Apt / Unit (optional)
                  <input type="text" name="unit" placeholder="Apt 12B">
                </label>
              </div>
              <div class="row">
                <label>City
                  <input type="text" name="city" placeholder="Miami" required>
                </label>
                <label>State
                  <input type="text" name="state" placeholder="FL" required>
                </label>
              </div>
              <div class="row-1">
                <label>ZIP Code
                  <input type="text" name="zip" placeholder="33101" required>
                </label>
              </div>
            </div>

            <!-- PAYMENT SECTION -->
            <div class="section">
              <div class="payment-header">
                <h3>Payment</h3>
                <div class="card-brand-logos" aria-label="Accepted payment methods">
                  <svg viewBox="0 0 80 24" role="img" aria-label="Visa">
                    <rect width="80" height="24" rx="4" fill="#1a1f71"/>
                    <text x="8" y="17" fill="#ffffff" font-size="14" font-family="Inter, 'Helvetica Neue', Arial, sans-serif" font-weight="700">VISA</text>
                  </svg>
                  <svg viewBox="0 0 80 24" role="img" aria-label="Mastercard">
                    <rect width="80" height="24" rx="4" fill="#ffffff" stroke="#e2e8f0"/>
                    <circle cx="34" cy="12" r="9" fill="#eb001b"/>
                    <circle cx="46" cy="12" r="9" fill="#f79e1b" fill-opacity="0.9"/>
                  </svg>
                  <svg viewBox="0 0 150 24" role="img" aria-label="American Express">
                    <rect width="150" height="24" rx="4" fill="#2e77bb"/>
                    <text x="10" y="16" fill="#ffffff" font-size="11" font-family="Inter, 'Helvetica Neue', Arial, sans-serif" font-weight="700" letter-spacing="1">AMERICAN EXPRESS</text>
                  </svg>
                  <svg viewBox="0 0 110 24" role="img" aria-label="Discover">
                    <rect width="110" height="24" rx="4" fill="#ffffff" stroke="#e2e8f0"/>
                    <text x="8" y="16" fill="#111827" font-size="12" font-family="Inter, 'Helvetica Neue', Arial, sans-serif" font-weight="700">DISCOVER</text>
                    <circle cx="90" cy="12" r="8" fill="#f58220"/>
                  </svg>
                </div>
              </div>
              <div class="row-1 payment-body">
                <div class="card payment-card">
                  <div class="card-body">

<div class="zp-fields" id="authnet-fields">
  <div class="row-1">
    <label class="zp-label" for="cardName">Name on card</label>
    <input id="cardName" class="zp-input" type="text" autocomplete="cc-name" placeholder="Full name"/>
  </div>

  <div class="row-1" style="margin-top:10px">
    <label class="zp-label" for="cardNumber">Card number</label>
    <input id="cardNumber" class="zp-input" type="tel" inputmode="numeric" autocomplete="cc-number" placeholder="1234 1234 1234 1234"/>
  </div>

  <div class="zp-row" style="margin-top:10px">
    <div>
      <label class="zp-label" for="cardExp">Expiration</label>
      <input id="cardExp" class="zp-input" type="tel" inputmode="numeric" autocomplete="cc-exp" placeholder="MM/YY"/>
    </div>
    <div>
      <label class="zp-label" for="cardCvv">CVV</label>
      <input id="cardCvv" class="zp-input" type="tel" inputmode="numeric" autocomplete="cc-csc" placeholder="123"/>
    </div>
  </div>

  <div id="pay-msg" class="zp-hint">Card details are tokenized securely by Authorize.net (Accept.js).</div>
  <div id="pay-error" class="zp-error" role="alert" aria-live="polite"></div>
</div>

                  </div>
                </div>
                <div class="policy-links">
                  <a href="/policy/terms" target="_blank" rel="noopener">Terms of Service</a>
                  <a href="/policy/privacy" target="_blank" rel="noopener">Privacy Policy</a>
                  <a href="/policy/delivery" target="_blank" rel="noopener">Delivery Policy</a>
                  <a href="/policy/refund" target="_blank" rel="noopener">Refund Policy</a>
                  <a href="/policy/cancellations" target="_blank" rel="noopener">Cancellation Policy</a>
                </div>
              </div>
            </div>
            <!-- END PAYMENT SECTION -->

          </div>
        </div>
      </div>

      <!-- RIGHT: order summary -->
      <aside class="summary">
        <div class="card">
          <div class="card-body">
            <h3 style="margin-top:0; text-transform:none; letter-spacing:0; font-size:16px;">Order summary</h3>

            <div id="order-items-container"></div>

            <div class="totals">
              <div class="line"><span>Subtotal</span><span id="summary-subtotal">$0.00</span></div>
              <div class="line"><span>Delivery</span><span id="summary-delivery">$0.00</span></div>
              <div class="line"><span>Tax (est)</span><span id="summary-tax">$0.00</span></div>
              <div class="line grand"><span>Total</span><span id="summary-total">$0.00</span></div>
            </div>

            <div class="actions" style="margin-top:16px">

              <button type="button" id="zp-pay-btn" class="btn btn-primary" style="width:100%">Complete Order</button>
              <a class="btn btn-secondary" href="/cart" style="width:100%">Back to cart</a>
            </div>
            <input type="hidden" id="agechecker_uuid" value="">

          </div>
        </div>
      </aside>
    </div>
  </div>

  <!-- Authorize.Net Accept.js -->
  <script src="https://js.authorize.net/v1/Accept.js"></script>

  <div id="policy-modal" class="policy-modal" role="dialog" aria-modal="true" aria-labelledby="policy-modal-title">
    <div class="policy-modal__dialog">
      <button type="button" id="policy-modal-close" class="policy-modal__close" aria-label="Close policy details">√ó</button>
      <div id="policy-modal-content" class="policy-modal__content"></div>
    </div>
  </div>

  <script>
    // Global state
    let allStores = [];
    let selectedStore = null;
    let cartProductIds = [];
    let cartItems = [];
    let cartItemCount = 0;
    let checkoutTotals = { subtotal: 0, tax: 0, delivery: 0, total: 0 };
    let deliveryStoreOptions = [];
    let selectedDeliveryStore = null;
    let userDeliveryLocation = null;

    // Render cart items and update totals
    (function(){
      const cart = JSON.parse(localStorage.getItem('cart')) || [];
      const container = document.getElementById('order-items-container');
      const TAX_RATE = 0.0875;

      cartItems = cart;

      // Robust ID extraction (supports different cart item shapes)
      const rawIds = cart
        .map((item) => item?.id ?? item?.product_id ?? item?.productId)
        .filter((v) => v !== null && v !== undefined && v !== '');

      // Use distinct product IDs for availability checks / readiness badges.
      cartProductIds = Array.from(new Set(rawIds.map((v) => parseInt(v, 10)).filter((n) => Number.isFinite(n))));
      cartItemCount = cartProductIds.length;


      if (cart.length === 0) {
        container.innerHTML = '<p style="color:#64748b; margin-bottom:16px;">Your cart is empty</p>';
      } else {
        let itemsHtml = '';
        let subtotal = 0;

        cart.forEach(item => {
          const price = typeof item.price === 'string' ? parseFloat(item.price.replace('$', '')) : (item.price || 0);
          const itemTotal = price * (item.quantity || 1);
          subtotal += itemTotal;
          itemsHtml += `
            <div class="line" style="font-size:13px; padding:8px 0;">
              <span>${item.name} <span style="color:#64748b;">√ó${item.quantity}</span></span>
              <span>$${itemTotal.toFixed(2)}</span>
            </div>
          `;
        });

        const tax = subtotal * TAX_RATE;
        const delivery = 0;
        const total = subtotal + tax + delivery;

        checkoutTotals = { subtotal, tax, delivery, total };

        container.innerHTML = itemsHtml + '<div style="border-bottom:1px solid #e2e8f0; margin-bottom:8px;"></div>';

        document.getElementById('summary-subtotal').textContent = `$${subtotal.toFixed(2)}`;
        document.getElementById('summary-delivery').textContent = `$${delivery.toFixed(2)}`;
        document.getElementById('summary-tax').textContent = `$${tax.toFixed(2)}`;
        document.getElementById('summary-total').textContent = `$${total.toFixed(2)}`;
      }
    })();

    function updateSummaryDelivery() {
      const deliveryEl = document.getElementById('summary-delivery');
      const totalEl = document.getElementById('summary-total');
      if (deliveryEl) deliveryEl.textContent = `$${checkoutTotals.delivery.toFixed(2)}`;
      if (totalEl) totalEl.textContent = `$${checkoutTotals.total.toFixed(2)}`;
    }

    function setDeliveryFee(amount) {
      const value = typeof amount === 'number' && !Number.isNaN(amount) ? amount : 0;
      checkoutTotals.delivery = value;
      checkoutTotals.total = checkoutTotals.subtotal + checkoutTotals.tax + checkoutTotals.delivery;
      updateSummaryDelivery();
    }

    function haversineMiles(lat1, lon1, lat2, lon2) {
      const R = 3959;
      const dLat = ((lat2 - lat1) * Math.PI) / 180;
      const dLon = ((lon2 - lon1) * Math.PI) / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((lat1 * Math.PI) / 180) *
          Math.cos((lat2 * Math.PI) / 180) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function estimateDeliveryFee(distance) {
      if (!distance || Number.isNaN(distance)) return 9.99;
      const surcharge = Math.max(0, distance - 4) * 1.25;
      return Math.min(24.99, 10.99 + surcharge);
    }

    function normalizeStreetTokens(street) {
      if (!street) return '';
      const map = {
        first: '1st', second: '2nd', third: '3rd', fourth: '4th', fifth: '5th',
        sixth: '6th', seventh: '7th', eighth: '8th', eight: '8th', ninth: '9th', tenth: '10th'
      };
      return street.replace(/\b(first|second|third|fourth|fifth|sixth|seventh|eighth|eight|ninth|tenth)\b/gi,
        (match) => map[match.toLowerCase()] || match
      );
    }
    async function geocodeAddressWithFallback(street, city, state, zip) {
      // IMPORTANT: Browser-to-Nominatim requests are blocked by CORS/403.
      // We proxy geocoding through our own backend (/api/geocode), which adds
      // the required User-Agent and avoids leaking third-party calls to the browser.
      try {
        const qs = new URLSearchParams({
          street: (street || "").trim(),
          city: (city || "").trim(),
          state: (state || "").trim(),
          zip: (zip || "").trim(),
          country: "US",
        });

        const resp = await fetch(`/api/geocode?${qs.toString()}`, {
          method: "GET",
          headers: { "Accept": "application/json" },
        });

        if (!resp.ok) {
          // 4xx/5xx: treat as no result, but surface debug text
          let msg = "";
          try { msg = await resp.text(); } catch {}
          console.warn("[geocode] backend failed", resp.status, msg.slice(0, 200));
          return null;
        }

        const data = await resp.json();
        if (!data || !data.lat || !data.lng) return null;

        return {
          lat: Number(data.lat),
          lng: Number(data.lng),
          display_name: data.display_name || data.displayName || "",
        };
      } catch (err) {
        console.warn("[geocode] exception", err);
        return null;
      }
    }

    function clearDeliveryOptions() {
      deliveryStoreOptions = [];
      selectedDeliveryStore = null;
      const header = document.getElementById('delivery-header');
      if (header) header.textContent = 'Delivery to';
      const container = document.getElementById('delivery-stores');
      if (container) { container.innerHTML = ''; container.style.display = 'none'; }
      const info = document.getElementById('closest-store-info');
      if (info) info.style.display = 'none';
      const notice = document.getElementById('delivery-availability-notice');
      if (notice) notice.style.display = 'none';
      setDeliveryFee(0);
    }

    function updateClosestStoreHighlight(closest) {
      const info = document.getElementById('closest-store-info');
      if (!info || !closest) { if (info) info.style.display = 'none'; return; }
      const nameEl = document.getElementById('closest-store-name');
      const addressEl = document.getElementById('closest-store-address');
      const distanceEl = document.getElementById('closest-store-distance');
      const feeEl = document.getElementById('closest-store-fee');
      if (nameEl) nameEl.textContent = closest.name;
      if (addressEl) addressEl.textContent = closest.address;
      if (distanceEl) distanceEl.textContent = Number.isFinite(closest.distance) ? closest.distance.toFixed(1) : '‚Äì';
      if (feeEl) feeEl.textContent = closest.fee.toFixed(2);
      info.style.display = 'block';
    }

    function updateDeliveryNotice(selectedOption) {
      const notice = document.getElementById('delivery-availability-notice');
      if (!notice) return;
      const messages = [];

      // Option B: Uber delivery should only be available when at least one store
      // can fulfill the entire cart (fully stocked). If none can, force pickup.
      const eligibleCount = (deliveryStoreOptions || []).filter(o => o && o.missingCount === 0).length;
      if (eligibleCount === 0) {
        notice.innerHTML = 'Uber delivery is not available for this cart (no location has all items). Please choose pickup or adjust your cart.';
        notice.style.display = 'block';
        return;
      }
      const closest = deliveryStoreOptions[0];
      if (closest && closest.missingCount > 0) messages.push(`Closest store (${closest.name}) is missing ${closest.missingCount} item(s).`);
      if (selectedOption && selectedOption.missingCount > 0) messages.push(`${selectedOption.name} cannot fulfill your full cart. Choose another store or swap items.`);
      if (selectedOption && selectedOption.warning) messages.push(`<strong>Note:</strong> ${selectedOption.warning}`);
      
      if (messages.length > 0) { notice.innerHTML = messages.join('<br>'); notice.style.display = 'block'; }
      else { notice.style.display = 'none'; }
    }

    function renderDeliveryStores() {
      const container = document.getElementById('delivery-stores');
      const helper = document.getElementById('delivery-store-helper');
      if (!container) return;

      if (!deliveryStoreOptions.length) {
        container.innerHTML = '';
        container.style.display = 'none';
        if (helper) helper.style.display = 'block';
        updateClosestStoreHighlight(null);
        updateDeliveryNotice(null);
        return;
      }

      if (helper) helper.style.display = 'none';

      // Phase 2: Prioritize the best store. Only show eligible stores to avoid confusion.
      const totalItems = cartItemCount;
      const eligibleStores = deliveryStoreOptions.filter(o => o.missingCount === 0);
      
      const cards = eligibleStores.map((option, idx) => {
        const isBest = idx === 0;
        const checked = (selectedDeliveryStore ? selectedDeliveryStore === option.name : isBest);
        const availabilityLabel = totalItems ? `${option.availableCount}/${totalItems} ready` : 'Cart empty';
        const distanceLabel = Number.isFinite(option.distance) ? option.distance.toFixed(1) : '‚Äì';
        const secondaryLine = `~${distanceLabel} miles ‚Ä¢ Delivery fee $${option.fee.toFixed(2)}`;

        return `
          <label class="store-option">
            <input type="radio" name="store_delivery" value="${option.name}" ${checked ? 'checked' : ''}>
            <div class="store-header">
              <div class="store-name">${option.name} ${isBest ? '<span class="best-badge">Best Choice</span>' : ''}</div>
              <span class="availability available">${availabilityLabel}</span>
            </div>
            <div class="store-address">${option.address}</div>
            <div class="store-distance">${secondaryLine}</div>
          </label>
        `;
      }).join('');

      container.innerHTML = cards;
      container.style.display = 'block';

      container.querySelectorAll('input[name="store_delivery"]').forEach(input => {
        input.addEventListener('change', (e) => {
          selectedDeliveryStore = e.target.value;
          applyDeliverySelection();
        });
      });

      applyDeliverySelection();
    }

    function applyDeliverySelection() {
      if (!deliveryStoreOptions.length) {
        setDeliveryFee(0);
        updateClosestStoreHighlight(null);
        updateDeliveryNotice(null);
        return;
      }

      const eligibleStores = deliveryStoreOptions.filter(o => o.missingCount === 0);
      if (!eligibleStores.length) {
        // No store can fulfill the full cart: Uber Delivery not available.
        setDeliveryFee(0);
        updateClosestStoreHighlight(null);
        updateDeliveryNotice(null);

        // Force pickup selection in the UI.
        const pickupRadio = document.querySelector('input[name="delivery_method"][value="pickup"]');
        if (pickupRadio && !pickupRadio.checked) {
          pickupRadio.checked = true;
          pickupRadio.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
      }

      if (!selectedDeliveryStore || !eligibleStores.some(o => o.name === selectedDeliveryStore)) {
        selectedDeliveryStore = eligibleStores[0].name;
      }

      const selectedOption = eligibleStores.find(option => option.name === selectedDeliveryStore) || eligibleStores[0];
      selectedDeliveryStore = selectedOption.name;
      setDeliveryFee(selectedOption.fee);
      updateClosestStoreHighlight(selectedOption);
      updateDeliveryNotice(selectedOption);
    }

    async function buildDeliveryStoreOptions(lat, lng) {
      if (!allStores.length) { clearDeliveryOptions(); return; }

      const helper = document.getElementById('delivery-store-helper');
      const container = document.getElementById('delivery-stores');
      const street = document.querySelector('input[name="street"]').value.trim();
      const city = document.querySelector('input[name="city"]').value.trim();
      const state = document.querySelector('input[name="state"]').value.trim();
      const zip = document.querySelector('input[name="zip"]').value.trim();

      const dropoffAddress = {
        street_address: [street].filter(Boolean),
        address: street,
        city,
        state,
        zip_code: zip,
        country: 'US'
      };

      try {
        if (helper) helper.textContent = 'Comparing store inventory and delivery fees‚Ä¶';

        const res = await fetch('/api/uber/delivery-options', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dropoffAddress, cartItems, lat, lng })
        });

        if (!res.ok) throw new Error('Failed to fetch delivery options');

        const { options } = await res.json();
        
        // Map backend response to frontend format
        const results = (options || []).map(opt => ({
          ...opt,
          // Use backend provided distance and fee
          distance: opt.distance || 0,
          fee: opt.fee || 0,
          availableCount: opt.inventory.availableCount,
          missingCount: opt.inventory.missingCount
        }));

        // Sort: 
        // 1. Fully stocked stores first
        // 2. Then by distance (closest first)
        results.sort((a, b) => {
          if (a.missingCount === 0 && b.missingCount > 0) return -1;
          if (a.missingCount > 0 && b.missingCount === 0) return 1;
          return a.distance - b.distance;
        });

        deliveryStoreOptions = results;

        // Auto-select the absolute best choice (results[0] after sorting by stock & distance)
        if (results.length > 0) {
          selectedDeliveryStore = results[0].name;
        }

        renderDeliveryStores();

      } catch (err) {
        console.error('Error fetching delivery options:', err);
        if (helper) helper.textContent = 'Something went wrong while finding nearby stores. Please try again.';
        clearDeliveryOptions();
      }
    }
    async function initializeStores() {
      try {
        // Container for pickup store buttons
        const pickupStoreContainer = document.getElementById('pickup-stores');
        const res = await fetch('/api/stores');
        const data = await res.json();
        // Support both { stores: [] } and direct array response
        allStores = Array.isArray(data) ? data : (Array.isArray(data?.stores) ? data.stores : []);

        if (!allStores.length) {
          if (pickupStoreContainer) {
            pickupStoreContainer.innerHTML = '<p class="error-message">No pickup stores available.</p>';
          }
          return;
        }

        window.initializeStores = initializeStores;

        // Respect the store the user is shopping from (passed via ?shop=... or from storage)
        const params = new URLSearchParams(window.location.search);
        const shopParamRaw = params.get('shop') || 
                            localStorage.getItem('preferredShop') || 
                            localStorage.getItem('selectedShop') || 
                            localStorage.getItem('selectedStore') || 
                            localStorage.getItem('shop') || 
                            '';
        const normalizeKey = (v) => String(v || '').toLowerCase().replace(/[^a-z0-9]/g, '');
        const shopKey = normalizeKey(shopParamRaw);

        let matched = null;
        if (shopKey) {
          matched = allStores.find((s) => {
            const candidates = [s?.id, s?.external_store_id, s?.externalStoreId, s?.slug, s?.name, s?.title, s?.storeId];
            return candidates.some((c) => normalizeKey(c) === shopKey);
          }) || null;

          // Fallback: allow partial matches like 'calle8' vs 'calle 8'
          if (!matched) {
            matched = allStores.find((s) => {
              const nameKey = normalizeKey(s?.name);
              return nameKey && shopKey && (nameKey.includes(shopKey) || shopKey.includes(nameKey));
            }) || null;
          }
        }

        selectedStore = matched?.name || null;

        // For Uber Delivery, prefer the shopping store when possible;
        // buildDeliveryStoreOptions() will fall back to the closest fully-stocked store if needed.
        selectedDeliveryStore = selectedStore;

        await renderPickupStores();

      } catch (err) {
        console.error('Error loading stores:', err);
        const pickupStoreContainer = document.getElementById('pickup-stores');
        if (pickupStoreContainer) {
          pickupStoreContainer.innerHTML = '<p class="error-message">Failed to load pickup stores.</p>';
        }
      }
    }

    async function renderPickupStores() {
      const container = document.getElementById('pickup-stores');
      if (!container) return;

      if (!allStores.length) {
        container.innerHTML = '<p class="error-message">No pickup stores available.</p>';
        return;
      }

      // Phase 1: Only show the store the user selected on the products page.
      const storesToRender = selectedStore 
        ? allStores.filter(s => s.name === selectedStore)
        : allStores;

      const totalItems = cartItemCount;
      const results = await Promise.all(storesToRender.map(async store => {
        const availability = await getStoreAvailability(store.name);
        const availableCount = Object.values(availability || {}).filter(Boolean).length;
        const isFullyAvailable = totalItems ? (availableCount === totalItems) : true;
        return { ...store, availableCount, isFullyAvailable };
      }));

      container.innerHTML = results.map(store => {
        const checked = selectedStore === store.name;
        const statusLabel = totalItems ? `${store.availableCount}/${totalItems} ready` : 'Cart empty';
        return `
          <label class="store-option">
            <input type="radio" name="store_pickup" value="${store.name}" ${checked ? 'checked' : ''}>
            <div class="store-header">
              <div class="store-name">${store.name}</div>
              <span class="availability ${store.isFullyAvailable ? 'available' : 'unavailable'}">${statusLabel}</span>
            </div>
            <div class="store-address">${store.address || ''}</div>
          </label>
        `;
      }).join('');

      container.querySelectorAll('input[name="store_pickup"]').forEach(input => {
        input.addEventListener('change', (e) => {
          selectedStore = e.target.value;
          // Synchronize with selectedDeliveryStore if not already set by address
          if (!userDeliveryLocation) {
             selectedDeliveryStore = selectedStore;
          }
          checkInventoryForStore(selectedStore);
        });
      });

      if (selectedStore) {
        checkInventoryForStore(selectedStore);
      } else {
        const notice = document.getElementById('pickup-availability-notice');
        if (notice) {
          notice.innerHTML = 'Please select a pickup location.';
          notice.style.display = 'block';
        }
      }
    }

    async function getStoreAvailability(storeName) {
      if (cartProductIds.length === 0) return {};
      try {
        const res = await fetch('/api/check-inventory', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ product_ids: cartProductIds, store_name: storeName })
        });
        if (!res.ok) throw new Error('Failed to check inventory');
        return await res.json();
      } catch (err) {
        console.error('Error checking inventory:', err);
        return {};
      }
    }

    async function checkInventoryForStore(storeName) {
      const availability = await getStoreAvailability(storeName);
      const unavailable = Object.entries(availability)
        .filter(([_, available]) => !available)
        .map(([id, _]) => cartProductIds.indexOf(parseInt(id)))
        .filter(i => i !== -1);

      const notice = document.getElementById('pickup-availability-notice');
      if (unavailable.length > 0) {
        notice.innerHTML = `‚ö†Ô∏è ${unavailable.length} item(s) not available at ${storeName}`;
        notice.style.display = 'block';
      } else {
        notice.style.display = 'none';
      }
    }

    (function(){
      const radios = document.querySelectorAll('input[name="delivery_method"]');
      const addressInputs = Array.from(document.querySelectorAll('input[name="street"],input[name="unit"],input[name="city"],input[name="state"],input[name="zip"]'));
      const pickupSection = document.getElementById('pickup-stores-section');
      const deliverySection = document.getElementById('delivery-stores-section');
      const addressSection = document.getElementById('address-section');

      function update(){
        const method = (document.querySelector('input[name="delivery_method"]:checked')||{}).value;
        const isDelivery = method === 'delivery' || method === 'uber';

        pickupSection.style.display = isDelivery ? 'none' : 'block';
        deliverySection.style.display = isDelivery ? 'block' : 'none';
        addressSection.style.display = isDelivery ? 'block' : 'none';

        addressInputs.forEach(i=>{
          i.disabled = !isDelivery;
          i.required = isDelivery;
        });

        if (isDelivery) {
          if (deliveryStoreOptions.length) applyDeliverySelection();
          else if (userDeliveryLocation) buildDeliveryStoreOptions(userDeliveryLocation.lat, userDeliveryLocation.lng);
          else setDeliveryFee(0);
        } else {
          setDeliveryFee(0);
          const deliveryNotice = document.getElementById('delivery-availability-notice');
          if (deliveryNotice) deliveryNotice.style.display = 'none';
        }
      }

      radios.forEach(r=>r.addEventListener('change', update));
      update();
    })();

    (function(){
      const addressInputs = Array.from(document.querySelectorAll('input[name="street"],input[name="unit"],input[name="city"],input[name="state"],input[name="zip"]'));
      const debounceDelay = 1500;
      let debounceTimer;

      async function findClosestStore() {
        const street = document.querySelector('input[name="street"]').value.trim();
        const city = document.querySelector('input[name="city"]').value.trim();
        const state = document.querySelector('input[name="state"]').value.trim();
        const zip = document.querySelector('input[name="zip"]').value.trim();
        const helper = document.getElementById('delivery-store-helper');

        if (!street || !city || !state || !zip) {
          if (helper) {
            helper.style.display = 'block';
            helper.textContent = 'Enter your address to compare store inventory and delivery fees.';
          }
          clearDeliveryOptions();
          return;
        }

        if (helper) {
          helper.style.display = 'block';
          helper.textContent = 'Finding stores near you‚Ä¶';
        }

        try {
          const coords = await geocodeAddressWithFallback(street, city, state, zip);

          if (!coords) {
            if (helper) helper.textContent = 'Could not locate that address. Double-check the details.';
            clearDeliveryOptions();
            return;
          }

          userDeliveryLocation = coords;
          
          const header = document.getElementById('delivery-header');
          if (header) {
            header.textContent = coords.display_name ? `Delivery to: ${coords.display_name.split(',').slice(0, 2).join(',')}` : 'Delivery to';
          }

          await buildDeliveryStoreOptions(coords.lat, coords.lng);
        } catch (err) {
          console.error('Error finding closest store:', err);
          if (helper) helper.textContent = 'Something went wrong while finding nearby stores.';
          clearDeliveryOptions();
        }
      }

      addressInputs.forEach(input => {
        input.addEventListener('input', () => {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(findClosestStore, debounceDelay);
        });
      });
    })();

    const policyModal = document.getElementById('policy-modal');
    const policyModalContent = document.getElementById('policy-modal-content');
    const policyModalClose = document.getElementById('policy-modal-close');

    function openPolicyModal(url, label) {
      if (!policyModal || !policyModalContent) return;
      policyModal.classList.add('show');
      policyModalContent.innerHTML = `<p class="policy-modal__loading">Loading ${label}‚Ä¶</p>`;
      fetch(url, { headers: { 'X-Requested-With': 'fetch' } })
        .then((res) => res.text())
        .then((html) => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const title = doc.querySelector('.policy-title')?.textContent?.trim() || label;
          const subtitle = doc.querySelector('.policy-subtitle')?.textContent?.trim() || '';
          const bodyNode = doc.querySelector('.policy-content') || doc.body;
          policyModalContent.innerHTML = `
            <div class="policy-modal__header">
              <h4 id="policy-modal-title">${title}</h4>
              ${subtitle ? `<p>${subtitle}</p>` : ''}
            </div>
            <div class="policy-modal__body">${bodyNode.innerHTML}</div>
          `;
        })
        .catch(() => {
          policyModalContent.innerHTML = `
            <p class="policy-modal__error">
              Unable to load ${label}. <a href="${url}" target="_blank" rel="noopener">Open policy</a>
            </p>
          `;
        });
    }

    function closePolicyModal() {
      if (!policyModal) return;
      policyModal.classList.remove('show');
    }

    function setupPolicyLinks() {
      const links = document.querySelectorAll('.policy-links a');
      links.forEach((link) => {
        link.addEventListener('click', (event) => {
          event.preventDefault();
          openPolicyModal(link.href, link.textContent.trim());
        });
      });
      if (policyModalClose) policyModalClose.addEventListener('click', closePolicyModal);
      if (policyModal) {
        policyModal.addEventListener('click', (event) => {
          if (event.target === policyModal) closePolicyModal();
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') closePolicyModal();
      });
    }

    window.addEventListener('load', () => {
      initializeStores();
      setupPolicyLinks();
    });

    /* ---------------- Authorize.Net Accept.js init ---------------- */
    const AUTH_NET_LOGIN_ID = <%- JSON.stringify((typeof authorizeLoginId !== 'undefined') ? authorizeLoginId : '') %>;
    const AUTH_NET_CLIENT_KEY = <%- JSON.stringify((typeof authorizeClientKey !== 'undefined') ? authorizeClientKey : '') %>;

    function paySetError(msg) {
      const el = document.getElementById('pay-error');
      if (el) el.textContent = msg || '';
    }

    function paySetHint(msg) {
      const el = document.getElementById('pay-msg');
      if (el) el.textContent = msg || '';
    }

    function getSelectedDeliveryMethod() {
      const method = (document.querySelector('input[name="delivery_method"]:checked') || {}).value;
      return method || 'pickup';
    }

    function buildBillingFromForm() {
      const email = document.querySelector('input[name="email"]')?.value?.trim() || '';
      const firstName = document.querySelector('input[name="first_name"]')?.value?.trim() || '';
      const lastName = document.querySelector('input[name="last_name"]')?.value?.trim() || '';
      const phone = document.querySelector('input[name="phone"]')?.value?.trim() || '';

      const street = document.querySelector('input[name="street"]')?.value?.trim() || '';
      const unit = document.querySelector('input[name="unit"]')?.value?.trim() || '';
      const city = document.querySelector('input[name="city"]')?.value?.trim() || '';
      const state = document.querySelector('input[name="state"]')?.value?.trim() || '';
      const zip = document.querySelector('input[name="zip"]')?.value?.trim() || '';

      const addressLine = [street, unit].filter(Boolean).join(' ');
      return {
        customer: { email, firstName, lastName, phone },
        billing: {
          firstName,
          lastName,
          phoneNumber: phone,
          phone,
          street,
          address: street || addressLine,
          address2: unit,
          street2: unit,
          unit,
          city,
          state,
          zip,
          country: 'US'
        }
      };
    }

    function parseExp(exp) {
      const raw = String(exp || '').replace(/\s+/g, '');
      const m = raw.match(/^(\d{2})\s*\/?\s*(\d{2}|\d{4})$/);
      if (!m) return null;
      const month = m[1];
      let year = m[2];
      if (year.length === 2) year = `20${year}`;
      return { month, year };
    }

    async function submitCharge(opaqueData) {
      const { customer, billing } = buildBillingFromForm();

      const deliveryMethod = getSelectedDeliveryMethod();
      const pickupStoreId = (deliveryMethod === 'delivery')
        ? normalizeStoreId(selectedDeliveryStore || selectedStore)
        : normalizeStoreId(selectedStore);

      const selectedOption = (deliveryMethod === 'delivery' && deliveryStoreOptions.length)
        ? deliveryStoreOptions.find(o => o.name === selectedDeliveryStore)
        : null;

      // Ensure we have the latest UUID/token (AgeChecker returns different shapes depending on config/version)
      function extractAgeToken(v) {
        if (!v) return null;
        if (typeof v === 'string') {
          const s = v.trim();
          // Ignore status strings
          if (['verified', 'accepted', 'pending', 'denied', 'rejected', 'unverified'].includes(s.toLowerCase())) return null;
          // Token-like strings are usually long-ish
          if (s.length >= 12) return s;
          return null;
        }
        if (typeof v === 'object') {
          return (
            v.uuid || v.signature || v.token ||
            v.verification_token || v.verificationToken ||
            v.verification_uuid || v.verificationUuid ||
            v.id ||
            (v.data && (v.data.uuid || v.data.token || v.data.signature || v.data.verification_token))
          ) || null;
        }
        return null;
      }

      function getAgeCheckerToken() {
        // Prefer what we stored from onStatusChange
        let t = sessionStorage.getItem('agechecker_uuid') || localStorage.getItem('agechecker_uuid') || window.__agechecker_uuid;
        if (t) return t;
        // Fall back to whatever the SDK exposes
        if (typeof AgeChecker !== 'undefined' && typeof AgeChecker.status === 'function') {
          const s = AgeChecker.status();
          console.log("[submitCharge] AgeChecker.status() raw:", s);
          t = extractAgeToken(s);
          if (t) {
            sessionStorage.setItem('agechecker_uuid', t);
            localStorage.setItem('agechecker_uuid', t);
            window.__agechecker_uuid = t;
            return t;
          }
        }
        return null;
      }

      const ageUuid = getAgeCheckerToken();
      
      console.log("[submitCharge] Final payload UUID/Token:", ageUuid);

      const payload = {
        opaqueData,
        totals: checkoutTotals,
        customer,
        billing,
        deliveryMethod,
        isManual: !!selectedOption?.isManual,
        deliveryWarning: selectedOption?.warning || null,
        pickupStoreId,
        pickupStoreLabel: storeLabelFromId(pickupStoreId),
        pickupStore: selectedStore,
        selectedDeliveryStore,
        items: cartItems,
        agechecker_uuid: ageUuid
      };

      const resp = await fetch('/api/authorize/charge', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) throw new Error(data?.error || 'Payment failed. Please try again.');
      return data;
    }



    // Store id normalization (used for Uber pickup store selection)
    function normalizeStoreId(v) {
      const raw = String(v ?? '').trim().toLowerCase();
      const s = raw.replace(/\s+/g, '');
      if (!s) return '';
      if (s === '1' || s.includes('calle8') || s.includes('sw8') || s == 'calle8') return 'calle8';
      if (s === '2' || s.includes('79th') || s == '79th' || s.includes('79street') || s.includes('79') ) return '79th';
      if (s === '3' || s.includes('market') || s.includes('bodega') || s.includes('mkt')) return 'mkt';
      return raw; // fallback (server will normalize too)
    }

    function storeLabelFromId(id) {
      const s = normalizeStoreId(id);
      if (s === 'calle8') return 'Calle 8';
      if (s === '79th') return '79th Street';
      if (s === 'mkt') return 'Market';
      return String(id ?? '').trim();
    }

    function tokenizeAndPay() {
      const btn = document.getElementById('zp-pay-btn');
      if (!btn) return;


      // pull anything we already stored from onStatusChange
const storedAge = sessionStorage.getItem('agechecker_uuid') ||
                  localStorage.getItem('agechecker_uuid') ||
                  window.__agechecker_uuid ||
                  document.getElementById("agechecker_uuid")?.value;

if (storedAge) {
  window.__agechecker_uuid = storedAge;
  const hidden = document.getElementById("agechecker_uuid");
  if (hidden) hidden.value = storedAge;
}



      // AgeChecker verification check
      if (typeof AgeChecker !== 'undefined' && typeof AgeChecker.status === 'function') {
        const statusObj = AgeChecker.status();
        const status = (typeof statusObj === 'string') ? statusObj : statusObj?.status;
        const uuid = (typeof statusObj === 'object')
          ? (statusObj?.uuid || statusObj?.signature || statusObj?.token || statusObj?.verification_token || statusObj?.verificationToken)
          : null;
        
        console.log("[tokenizeAndPay] AgeChecker Status:", status, "Captured ID:", uuid);

        if (uuid) {
          sessionStorage.setItem('agechecker_uuid', uuid);
          localStorage.setItem('agechecker_uuid', uuid);
          window.__agechecker_uuid = uuid;
        }

        const sLower = String(status || '').toLowerCase();
        const isOk = (sLower === 'verified' || sLower === 'accepted');

        if (!isOk) {
          // Remember that the user clicked pay; when verification succeeds we auto-continue.
          window.__agechecker_pending_payment = true;
          AgeChecker.show();
          return;
        }
      }

      if (!AUTH_NET_LOGIN_ID || !AUTH_NET_CLIENT_KEY) {
        paySetError('Payment configuration missing (Authorize.net keys not set).');
        return;
      }

      paySetError('');

      if (!window.Accept || typeof window.Accept.dispatchData !== 'function') {
        paySetError('Authorize.Net Accept.js failed to load. Refresh and try again.');
        return;
      }

      const expObj = parseExp(document.getElementById('cardExp')?.value);
      if (!expObj) {
        paySetError('Expiration must be in MM/YY format.');
        return;
      }

      const cardData = {
        cardNumber: (document.getElementById('cardNumber')?.value || '').replace(/\s+/g, ''),
        month: expObj.month,
        year: expObj.year,
        cardCode: (document.getElementById('cardCvv')?.value || '').trim(),
        fullName: (document.getElementById('cardName')?.value || '').trim()
      };

      if (!cardData.cardNumber || !cardData.cardCode || !cardData.month || !cardData.year) {
        paySetError('Please fill out all card fields.');
        return;
      }

      btn.disabled = true;
      paySetHint('Processing payment‚Ä¶');

      const authData = {
        clientKey: AUTH_NET_CLIENT_KEY,
        apiLoginID: AUTH_NET_LOGIN_ID
      };

      window.Accept.dispatchData({ authData, cardData }, async (response) => {
        try {
          const result = response?.messages?.resultCode;
          if (result !== 'Ok') {
            const msg = response?.messages?.message?.[0]?.text || 'Card tokenization failed.';
            throw new Error(msg);
          }

          const opaqueData = response.opaqueData;
          if (!opaqueData?.dataDescriptor || !opaqueData?.dataValue) {
            throw new Error('Missing token from Authorize.Net.');
          }

          const serverResult = await submitCharge(opaqueData);

          paySetError('');
          paySetHint('Payment approved ‚úÖ');

          // Persist success payload for /checkout-success
          try {
            const orderId =
              serverResult?.receipt?.order_id ||
              serverResult?.receiptPayload?.orderId ||
              null;

            const deliveryMethod = getSelectedDeliveryMethod();

            // If the server provided a full payload (includes orderId + totals, etc.), prefer it.
            const successPayload = serverResult?.receiptPayload || {
              receipt: serverResult?.receipt || (orderId ? { order_id: orderId } : null),
              orderId,
              deliveryMethod,
              totals: checkoutTotals,
              pickupStoreId: pickupStoreId || null,
              pickupStoreLabel: storeLabelFromId(pickupStoreId) || null,
              serverDelivery: serverResult?.uberDelivery || serverResult?.delivery || null,
              uberError: serverResult?.uberError || null,
              deliveryWarning: serverResult?.uberError || null
            };

            sessionStorage.setItem('checkoutSuccessPayload', JSON.stringify(successPayload));
            try { localStorage.setItem('checkoutSuccessPayload_backup', JSON.stringify(successPayload)); } catch (_) {}

            const tx = serverResult?.transactionId ? `tx=${encodeURIComponent(serverResult.transactionId)}` : '';
            const oid = orderId ? `orderId=${encodeURIComponent(orderId)}` : '';
            const qs = [oid, tx].filter(Boolean).join('&');
            const qsPart = qs ? `?${qs}` : '';
            setTimeout(() => { window.location.href = `/checkout-success${qsPart}`; }, 200);
          } catch (_) {
            setTimeout(() => { window.location.href = '/checkout-success'; }, 200);
          }
} catch (err) {
          paySetError(err?.message || 'Payment failed.');
          paySetHint('Please review your card details and try again.');
          btn.disabled = false;
        }
      });
    }

    window.tokenizeAndPay = tokenizeAndPay;

    function bindPayButton() {
      const btn = document.getElementById('zp-pay-btn');
      if (!btn) return;
      if (btn.dataset.bound === '1') return;
      btn.dataset.bound = '1';

      btn.addEventListener('click', (e) => {
        e.preventDefault();
        tokenizeAndPay();
      });
    }

    bindPayButton();
    document.addEventListener('DOMContentLoaded', bindPayButton);

    /* ---------------- Google Places Autocomplete ---------------- */
    function initAutocomplete() {
      const streetInput = document.querySelector('input[name="street"]');
      if (!streetInput) return;

      const autocomplete = new google.maps.places.Autocomplete(streetInput, {
        componentRestrictions: { country: "us" },
        fields: ["address_components", "geometry"],
        types: ["address"],
      });

      // Helper to restore Google Autocomplete UI visibility
      const restoreAutocompleteUI = () => {
        const containers = document.querySelectorAll('.pac-container');
        containers.forEach(c => {
          c.style.display = '';
          c.style.visibility = 'visible';
          c.style.opacity = '1';
        });
      };

      // Restore visibility whenever the user interacts with the input
      streetInput.addEventListener('input', restoreAutocompleteUI);
      streetInput.addEventListener('focus', restoreAutocompleteUI);

      // Handle the "Clear" button
      const clearBtn = document.getElementById('clear-street-btn');
      if (clearBtn) {
        clearBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Clear all related fields
          streetInput.value = '';
          const cityInput = document.querySelector('input[name="city"]');
          const stateInput = document.querySelector('input[name="state"]');
          const zipInput = document.querySelector('input[name="zip"]');
          if (cityInput) cityInput.value = '';
          if (stateInput) stateInput.value = '';
          if (zipInput) zipInput.value = '';
          
          // Reset UI
          restoreAutocompleteUI();
          streetInput.focus();
          
          // Trigger input event to refresh store logic
          streetInput.dispatchEvent(new Event('input', { bubbles: true }));
        });
      }

      // Prevent Enter key from submitting the form if a suggestion is highlighted
      streetInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          // If the Google Places dropdown is visible, prevent default to avoid accidental form submission
          const pacContainer = document.querySelector('.pac-container');
          const isVisible = pacContainer && 
                            pacContainer.style.display !== 'none' && 
                            window.getComputedStyle(pacContainer).display !== 'none';
          
          if (isVisible) {
            e.preventDefault();
          }
        }
      });

      autocomplete.addListener("place_changed", () => {
        const place = autocomplete.getPlace();
        if (!place.address_components) return;

        let streetNumber = "";
        let route = "";
        let city = "";
        let state = "";
        let zip = "";

        for (const component of place.address_components) {
          const componentType = component.types[0];

          switch (componentType) {
            case "street_number":
              streetNumber = component.long_name;
              break;
            case "route":
              route = component.short_name; 
              break;
            case "locality":
              city = component.long_name;
              break;
            case "administrative_area_level_1":
              state = component.short_name;
              break;
            case "postal_code":
              zip = component.long_name;
              break;
          }
        }

        // 1. Update the fields
        streetInput.value = `${streetNumber} ${route}`.trim();
        const cityInput = document.querySelector('input[name="city"]');
        const stateInput = document.querySelector('input[name="state"]');
        const zipInput = document.querySelector('input[name="zip"]');

        if (cityInput) cityInput.value = city;
        if (stateInput) stateInput.value = state;
        if (zipInput) zipInput.value = zip;

        // 2. Immediate cleanup of Google Autocomplete UI
        streetInput.blur();
        
        const dismissAutocomplete = () => {
          const containers = document.querySelectorAll('.pac-container');
          containers.forEach(c => {
            c.style.display = 'none';
          });
        };
        
        dismissAutocomplete();
        // Google sometimes re-triggers the dropdown after selection, so ensure it stays closed
        setTimeout(dismissAutocomplete, 50);
        setTimeout(dismissAutocomplete, 150);

        // 3. Trigger 'input' event so findClosestStore() and other logic runs
        streetInput.dispatchEvent(new Event('input', { bubbles: true }));
        if (cityInput) cityInput.dispatchEvent(new Event('input', { bubbles: true }));
        if (zipInput) zipInput.dispatchEvent(new Event('input', { bubbles: true }));
      });
    }
    window.initAutocomplete = initAutocomplete;
  </script>

  <!-- AgeChecker.net -->
  <script>
    (function(w,d) {
      var config = {
        key: "<%= ageCheckerApiKey %>",
        element: "#zp-pay-btn",
        debug: true,
        disable_fields: true,
        require_email: true,
        fields: {
          first_name: "input[name='first_name']",
          last_name: "input[name='last_name']",
          contact_email: "input[name='email']",
          // Your form uses name="street" (not "address")
          address: "input[name='street']",
          zip: "input[name='zip']",
          city: "input[name='city']",
          state: "input[name='state']",
          dob_month: "#dob_month",
          dob_day: "#dob_day",
          dob_year: "#dob_year"
        },
        onStatusChange: function(response) {
          console.log("[AgeChecker] Status change:", response);
          const status = (typeof response === 'string') ? response : response?.status;
          function extractToken(obj) {
  if (!obj || typeof obj !== "object") return null;

  // direct
  const direct =
    obj.uuid || obj.signature || obj.token ||
    obj.verification_token || obj.verificationToken ||
    obj.verification_uuid || obj.verificationUuid ||
    obj.id;

  if (direct) return direct;

  // nested common wrappers
  const nested = obj.data || obj.payload || obj.result || obj.verification || null;
  if (nested && typeof nested === "object") {
    return (
      nested.uuid || nested.signature || nested.token ||
      nested.verification_token || nested.verificationToken ||
      nested.verification_uuid || nested.verificationUuid ||
      nested.id
    ) || null;
  }

  return null;
}

const token = extractToken(response);
console.log("[AgeChecker] extracted token:", token);
if (token) {
  sessionStorage.setItem('agechecker_uuid', token);
  localStorage.setItem('agechecker_uuid', token);
  window.__agechecker_uuid = token;

  const hidden = document.getElementById("agechecker_uuid");
  if (hidden) hidden.value = token;
}


          if (token) {
            sessionStorage.setItem('agechecker_uuid', token);
            localStorage.setItem('agechecker_uuid', token);
            window.__agechecker_uuid = token;
          }

          // If the user already clicked "Complete Order" and verification just finished,
          // auto-continue without requiring a second click.
          const sLower = String(status || '').toLowerCase();
          const isOk = (sLower === 'verified' || sLower === 'accepted');
          if (isOk && window.__agechecker_pending_payment) {
            window.__agechecker_pending_payment = false;
            setTimeout(() => {
              try { tokenizeAndPay(); } catch (e) { console.error(e); }
            }, 50);
          }
        }
      };

      w.AgeCheckerConfig = config;

      var h=d.getElementsByTagName("head")[0];
      var a=d.createElement("script");
      a.src="https://cdn.agechecker.net/static/popup/v1/popup.js";
      a.crossOrigin="anonymous";
      a.onerror=function(){ w.location.href="https://agechecker.net/loaderror"; };
      h.insertBefore(a,h.firstChild);
    })(window, document);
  </script>

  <!-- Google Maps SDK for Places Autocomplete -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBY9pqxZth54lLRl-AqU4PhpCWGUAJuKbc&libraries=places&callback=initAutocomplete&loading=async" async defer></script>


  <noscript>
  <meta http-equiv="refresh" content="0;url=https://agechecker.net/noscript">
</noscript>

</body>
</html>
